<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enigma I Simulator</title>
    <style>
        body { font-family: 'Courier New', Courier, monospace; background-color: #2c3e50; color: #ecf0f1; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .container { background-color: #34495e; padding: 20px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); width: 100%; max-width: 600px; }
        h1 { text-align: center; border-bottom: 2px solid #f1c40f; padding-bottom: 10px; }
        .hidden { display: none; }
        label { display: block; margin-top: 15px; font-weight: bold; }
        select, input, button { width: 100%; padding: 10px; margin-top: 5px; border-radius: 4px; border: none; font-family: inherit; }
        button { background-color: #f1c40f; color: #2c3e50; font-weight: bold; cursor: pointer; transition: 0.3s; margin-top: 20px;}
        button:hover { background-color: #d4ac0d; }
        .output-box { background-color: #000; color: #0f0; padding: 15px; margin-top: 20px; min-height: 50px; word-wrap: break-word; letter-spacing: 2px; }
        .rotor-group { display: flex; gap: 10px; margin-bottom: 10px; }
        .rotor-select { flex: 1; }
        #esp-status { font-size: 0.8em; margin-top: 10px; text-align: center; color: #bdc3c7; }
    </style>
</head>
<body>

<div class="container" id="view-setup">
    <h1>Máquina Enigma I (1930)</h1>
    <p>Bienvenido. Seleccione la configuración inicial.</p>
    
    <label for="num-rotors">Número de rotores (3 a 5):</label>
    <select id="num-rotors">
        <option value="3">3 Rotores</option>
        <option value="4">4 Rotores</option>
        <option value="5">5 Rotores</option>
    </select>

    <label for="esp-ip">IP del ESP32 (Ej: 192.168.1.50):</label>
    <input type="text" id="esp-ip" placeholder="Ingresa la IP local del ESP32">

    <button onclick="goToMachine()">Continuar</button>
</div>

<div class="container hidden" id="view-machine">
    <h1>Operación Enigma</h1>
    
    <div id="rotors-container">
        </div>

    <label for="input-text">Texto a encriptar:</label>
    <input type="text" id="input-text" placeholder="SOLO MAYUSCULAS (A-Z)" oninput="this.value = this.value.toUpperCase().replace(/[^A-Z]/g, '')">

    <button onclick="processEncryption()">ENCRIPTAR Y ENVIAR</button>

    <label>Resultado Encriptado:</label>
    <div class="output-box" id="output-text"></div>
    <div id="esp-status"></div>
    
    <button onclick="location.reload()" style="background-color: #e74c3c; margin-top: 10px;">Reiniciar</button>
</div>

<script>
    // Configuración de Rotores y Reflector
    const rotorData = {
        'I':   { wiring: 'EKMFLGDQVZNTOWYHXUSPAIBRCJ', notch: 'Q' },
        'II':  { wiring: 'AJDKSIRUXBLHWTMCQGZNPYFVOE', notch: 'E' },
        'III': { wiring: 'BDFHJLCPRTXVZNYEIWGAKMUSQO', notch: 'V' },
        'IV':  { wiring: 'ESOVPZJAYQUIRHXLNFTGKDCMWB', notch: 'J' },
        'V':   { wiring: 'VZBRGITYUPSDNHLXAWMJQOFEKC', notch: 'Z' }
    };
    const reflectorWiring = 'YRUHQSLDPXNGOKMIEBFZCWVJAT';
    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

    let numRotors = 3;
    let espIP = "";

    function goToMachine() {
        numRotors = parseInt(document.getElementById('num-rotors').value);
        espIP = document.getElementById('esp-ip').value;
        
        const container = document.getElementById('rotors-container');
        container.innerHTML = '<label>Selección de Rotores (Izquierda a Derecha):</label>';

        for (let i = 0; i < numRotors; i++) {
            let select = document.createElement('select');
            select.className = 'rotor-select';
            select.id = `rotor-${i}`;
            Object.keys(rotorData).forEach(key => {
                let opt = document.createElement('option');
                opt.value = key;
                opt.innerText = `Rotor ${key}`;
                select.appendChild(opt);
            });
            // Pre-seleccionar distintos para evitar colisiones iniciales simples
            if(i < 5) select.selectedIndex = i; 
            container.appendChild(select);
        }

        document.getElementById('view-setup').classList.add('hidden');
        document.getElementById('view-machine').classList.remove('hidden');
    }

    function processEncryption() {
        const input = document.getElementById('input-text').value;
        const outputDiv = document.getElementById('output-text');
        
        // Validar rotores únicos
        let selectedRotors = [];
        for(let i=0; i<numRotors; i++) {
            let val = document.getElementById(`rotor-${i}`).value;
            if(selectedRotors.includes(val)) {
                alert("Error: Los rotores no pueden repetirse.");
                return;
            }
            selectedRotors.push(val);
        }

        // Configuración inicial de posiciones (A=0)
        // En una máquina real se pueden configurar, aquí asumiremos inicio en 'A' (0)
        // para simplificar la UI, o podríamos añadir inputs para Ring Setting.
        // Simularemos que arrancan en posición 0 (A).
        let positions = new Array(numRotors).fill(0); 
        
        let result = "";

        for (let i = 0; i < input.length; i++) {
            let charCode = alphabet.indexOf(input[i]);
            if (charCode === -1) continue; // Ignorar espacios o símbolos

            // --- PASO 1: ROTACIÓN (STEPPING) ---
            // Lógica simplificada de cascada para N rotores
            // El rotor más a la derecha (Fast) siempre gira.
            let rotate = new Array(numRotors).fill(false);
            
            // El rotor rápido (último) siempre gira
            rotate[numRotors - 1] = true;

            // Chequeo de notches para rotores intermedios (de derecha a izquierda)
            for (let r = numRotors - 1; r > 0; r--) {
                let currentRotorName = selectedRotors[r];
                let currentNotch = rotorData[currentRotorName].notch;
                let currentPosChar = alphabet[positions[r]];

                if (currentPosChar === currentNotch) {
                    rotate[r-1] = true; // El rotor a la izquierda debe girar
                    
                    // Doble paso (Double Step) - Característica de Enigma:
                    // Si el rotor medio está en su muesca, también avanza él mismo al empujar al izquierdo.
                    if (r < numRotors - 1) {
                         rotate[r] = true; 
                    }
                }
            }

            // Aplicar rotaciones
            for (let r = 0; r < numRotors; r++) {
                if (rotate[r]) {
                    positions[r] = (positions[r] + 1) % 26;
                }
            }

            // --- PASO 2: CIRCUITO ELÉCTRICO ---
            let signal = charCode;

            // Pasada de Ida (Derecha a Izquierda)
            for (let r = numRotors - 1; r >= 0; r--) {
                signal = rotorMap(signal, selectedRotors[r], positions[r], true);
            }

            // Reflector
            signal = mapChar(signal, reflectorWiring);

            // Pasada de Vuelta (Izquierda a Derecha)
            for (let r = 0; r < numRotors; r++) {
                signal = rotorMap(signal, selectedRotors[r], positions[r], false);
            }

            result += alphabet[signal];
        }

        outputDiv.innerText = result;
        sendToESP32(result);
    }

    // Función auxiliar para mapear a través de un rotor considerando su desplazamiento
    function rotorMap(inputIdx, rotorName, rotorPos, forward) {
        let wiring = rotorData[rotorName].wiring;
        // Ajuste por posición del anillo (offset)
        let offset = rotorPos;
        
        if (forward) {
            // Entrada + Offset -> Wiring -> Salida - Offset
            let indexIn = (inputIdx + offset) % 26;
            let charAtPin = alphabet[indexIn];
            let charMapped = wiring[alphabet.indexOf(charAtPin)];
            let indexOut = (alphabet.indexOf(charMapped) - offset + 26) % 26;
            return indexOut;
        } else {
            // Inverso: Entrada + Offset -> Wiring Inverso -> Salida - Offset
            let indexIn = (inputIdx + offset) % 26;
            let charAtPin = alphabet[indexIn];
            let wiringIndex = wiring.indexOf(charAtPin); // Buscar índice de la letra en el wiring
            let indexOut = (wiringIndex - offset + 26) % 26;
            return indexOut;
        }
    }

    function mapChar(idx, mappingString) {
        return alphabet.indexOf(mappingString[idx]);
    }

    function sendToESP32(text) {
        const statusDiv = document.getElementById('esp-status');
        if(!espIP) {
            statusDiv.innerText = "No se configuró IP para ESP32.";
            return;
        }

        statusDiv.innerText = "Enviando a ESP32...";
        
        // Usamos 'no-cors' para evitar errores básicos, pero el ESP32 debe manejar CORS headers
        // Nota: Desde HTTPS (GitHub Pages) a HTTP (ESP32 local) esto fallará en Chrome
        // a menos que se configure el navegador o se use un túnel.
        fetch(`http://${espIP}/recibir`, {
            method: 'POST',
            headers: {
                'Content-Type': 'text/plain',
            },
            body: text
        })
        .then(response => {
            statusDiv.innerText = "Enviado correctamente al ESP32.";
        })
        .catch(error => {
            console.error('Error:', error);
            statusDiv.innerText = "Error enviando (Revisar consola/Mixed Content).";
        });
    }
</script>

</body>
</html>
